# -*- coding: utf-8 -*-
"""Rede-neural.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eCiDvnxORZA2PrbxbO2lrsdeQq6r1bGJ
"""

#imports necessários para criação de uma rede neural para leitura de manuscritos por IA
import numpy as np
import torch
import torch.nn.functional as F
from torch import nn, optim
import torchvision
from torchvision import datasets, transforms
import matplotlib.pyplot as plt
from time import time

transform = transforms.ToTensor() #define a conversão de imagem para tensor, que é um padrão numérico

trainset = datasets.MNIST('./MNIST_data/', download = True, train = True, transform = transform) #carrega o treino do dataset
trainloader = torch.utils.data.DataLoader(trainset, batch_size = 64, shuffle = True) #cria buffer p/ carregar os dados por partes

valset = datasets.MNIST('./MNIST_data/', download = True, train = False, transform = transform) #carrega a parte de validação do dataset
valloader = torch.utils.data.DataLoader(valset, batch_size = 64, shuffle = True) #cria buffer p/ pegar os dados por partes

#ao executar, baixa as imagens do site yann.lecun.com para o dataset

#testar representação de eum dígito
dataiter = iter(trainloader)
imagens, etiquetas = next(dataiter)
plt.imshow(imagens[0].numpy().squeeze(), cmap = 'gray_r');

#conferir tamanho de uma imagem (ou seja, dimensões do tensor que a representa), e da etiqueta
print(imagens[0].shape)
print(etiquetas[0].shape)

#modelo da rede inceptionV3 pega em https://keras.io/api/applications/
class Modelo(nn.Module):
  def __init__(self):
    super(Modelo, self).__init__()
    self.linear1 = nn.Linear(28*28, 128) #camada de entrada, 784 neurônios q se ligam a 128
    self.linear2 = nn.Linear(128, 64) #camada interna 1, 128 neurônios q se ligam a 64
    self.linear3 = nn.Linear(64, 10) #camada interna 2, 64 neurônios q se ligam a 10

  def forward(self, X):
    X = F.relu(self.linear1(X)) #ativação da camada de entrada p/ interna 1
    X = F.relu(self.linear2(X)) #ativação da camada interna 1 p/ interna 2
    X = self.linear3(X) #ativação da camada interna 2 p/ de saída, nesse caso f(x)=x

    return F.log_softmax(X, dim = 1) #dados utilizados para calcular a perda

def treino(modelo, trainloader, device):

  otimizador = optim.SGD(modelo.parameters(), lr = 0.01, momentum = 0.5) #define a política de atualização dos pesdos e da bias
  inicio = time() #timer para sabermos quanto tempo levou o treino

  criterio = nn.NLLLoss() #definindo o critério para calcular a perda
  EPOCHS = 30 #numero de epochs que o algortimo rodará
  modelo.train() #ativando o modo de treinamento do modelo

  for epoch in range(EPOCHS):
    perda_acumulada = 0 #acumulador

    for imagens, etiquetas in trainloader:

      imagens = imagens.view(imagens.shape[0], -1) #converte as imagens p/ "vetores" de 28*28 casas
      otimizador.zero_grad() #zerando os gradientes por conta do ciclo anterior

      output = modelo(imagens.to(device)) #colocando os dados no modelo
      perda_instantanea = criterio(output, etiquetas.to(device)) #calcula a perda da epoch em questão

      perda_instantanea.backward() #back propagation a partir da perda

      otimizador.step() #atualizando os pesos e a bias

      perda_acumulada += perda_instantanea.item() #atualização da perda acumulada

#função para mostrar valor da acuracia
#chama imagens da rede treinada, e compara uma imagem não treinada com a rede pra ver se ela aprendeu
def validacao(modelo, valloader, device):
  conta_corretas, conta_todas = 0, 0
  for imagens, etiquetas in valloader:
    for i in range(len(etiquetas)):
      img = imagens[i].view(1, 784)
      #desativar autograd p/ acelerar a validação - grafos computacionais dinâmicos tem custo alto de processamento
      with torch.no_grad():
        logps = modelo(img.to(device)) #output do modelo em escala logaritmica

      ps = torch.exp(logps) #converte output p/ escala normal (que é um tensor)
      probab = list(ps.cpu().numpy()[0])
      etiqueta_pred = probab.index(max(probab)) #converte tensor em um numero - o nº que o modelo previu como correto
      etiqueta_certa = etiquetas.numpy()[i]
      if(etiqueta_certa == etiqueta_pred): #compara a previsão com o valor correto
        conta_corretas += 1
      conta_todas += 1

  print("Total de imagens testadas = ", conta_todas)
  print("\nPrecisão do modelo = {}%".format(conta_corretas*100/conta_todas))

#roda a classe modelo
modelo = Modelo()